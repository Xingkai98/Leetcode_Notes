
### 解法思路
Two sums
输入：一个数组中有且只有两个数，他们的和为某个给定的数t。
输出：给出这两个数的下标。
大致伪代码如下：
```
for i从头遍历：
    清空结果List
    temp=t-*i
    for j==i+1遍历：
        if temp == *j
            结束
```

### 最新Solution

C++
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        int target_t = 0;
        //choose the first
        for(auto i = nums.begin(); i != nums.end(); i++){
            res.clear();
            target_t = target - *i;
            res.push_back((int)(i-nums.begin()));
            
            //choose the second
            for(auto j = i+1; j != nums.end(); j++){
                if(*j == target_t){
                    res.push_back((int)(j-nums.begin()));
                    break;
                }
            }
            
            if(res.size() == 2)
                break;
        }
        return res;
    }
};
```
Python
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        t = 0
        #choose the first one
        for inxi, i in enumerate(nums):
            #clear the list for a new round
            res = []
            
            res.append(inxi)
            t = target - i
            
            #choose the second one 
            for inxj, j in enumerate(nums[inxi+1:]):
                if t == j:
                    
                    #add on inxi + 1 to offset relative index
                    res.append(inxj + inxi + 1)
                    return res
```
* * *
### 笔记
没什么算法的内容。

### 语法点复习
##### C++
```C++
vector<int> a;
```
（这里有可能会与java搞混，不需要new
##### Python
```Python
a = [1,2,3]
for index, i in enumerate(a):
    #do something
```
这里面，enumerate可以视为一种带下表的遍历list的方式。
其中，index在前，内容在后。
```Python
def twoSum(self, nums: List[int], target: int) -> List[int]:
```
Python中，函数可以不用规定返回值的性质，直接return即可；不过，函数规定返回值类型的方式倒是非常直观~
### 代码导航
[C++](codes-src\1_cpp.md)
[Python](codes-src\1_py.md)